#+TITLE: Emacs Configuration file
#+AUTHOR: Marcus Olofsson
#+BABEL: :cache yes
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage{inconsolata}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+PROPERTY: header-args :tangle yes

* About
  This is a Emacs configuration file written in [[http://orgmode.org][Org mode]]. It is an attempt
  to keep my =~/.emacs.d= tidy, but still be able to keep it all in one
  file. I aim to briefly explain all my configurations as I go along!

  On first run it should install a bunch of packages (this might take a
  while), and you might have to restart your Emacs the first time. If you
  experience bugs, please let me know!

  This is influensed by [[https://github.com/larstvei/dot-emacs.git][Lars Tvei's dot emacs]]... More heavely based on it,
  since I found his and thought it was such great idea to write the =init.el=
  in org and have it clean and nice.

* Configuration
** Meta
   All changes to the configuration should be done in =init.org=, *not* in
   =init.el=. Any changes in the =init.el= will be overwritten by saving
   =init.org=. The =init.el= in this repo should not be tracked by git, and
   is replaced the first time Emacs is started (assuming it has been renamed
   to =~/.emacs.d=).

   Emacs can't load =.org=-files directly, but =org-mode= provides functions
   to extract the code blocks and write them to a file. There are multiple
   ways of handling this; like suggested by [[http://emacs.stackexchange.com/questions/3143/can-i-use-org-mode-to-structure-my-emacs-or-other-el-configuration-file][this StackOverflow post]], one
   could just use =org-babel-load-file=, but I had problems with
   byte-compilation. Previously I tracked both the =org.=- and =el.=-files,
   but the git commits got a little messy. So here is a new approach.

   When this configuration is loaded for the first time, the ~init.el~ is
   the file that is loaded. It looks like this:

   #+BEGIN_SRC emacs-lisp :tangle no
   ;; This file replaces itself with the actual configuration at first run.

   ;; We can't tangle without org!
   (require 'org)
   ;; Open the configuration
   (find-file (concat user-emacs-directory "init.org"))
   ;; tangle it
   (org-babel-tangle)
   ;; load it
   (load-file (concat user-emacs-directory "init.el"))
   ;; finally byte-compile it
   (byte-compile-file (concat user-emacs-directory "init.el"))
   #+END_SRC

   It tangles the org-file, so that this file is overwritten with the actual
   configuration.

   There is no reason to track the =init.el= that is generated; by running
   the following command =git= will not bother tracking it:

   #+BEGIN_SRC sh :tangle no
   git update-index --assume-unchanged init.el
   #+END_SRC

   If one wishes to make changes to the repo-version of =init.el= start
   tracking again with:

   #+BEGIN_SRC sh :tangle no
   git update-index --no-assume-unchanged init.el
   #+END_SRC

   The =init.el= should (after the first run) mirror the source blocks in
   the =init.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which
   extracts the code blocks from the current file into a source-specific
   file (in this case a =.el=-file).

   To avoid doing this each time a change is made we can add a function to
   the =after-save-hook= ensuring to always tangle and byte-compile the
   =org=-document after changes.

   #+BEGIN_SRC emacs-lisp
   (defun tangle-init ()
     "If the current buffer is 'init.org' the code-blocks are
   tangled, and the tangled file is compiled."
     (when (equal (buffer-file-name)
                  (expand-file-name (concat user-emacs-directory "init.org")))
       ;; Avoid running hooks when tangling.
       (let ((prog-mode-hook nil))
         (org-babel-tangle)
         (byte-compile-file (concat user-emacs-directory "init.el")))))

   (add-hook 'after-save-hook 'tangle-init)
   #+END_SRC

   I'd like to keep a few settings private, so we load a =private.el= if it
   exists after the init-file has loaded.

   #+BEGIN_SRC emacs-lisp
   (add-hook
    'after-init-hook
    (lambda ()
      (let ((private-file (concat user-emacs-directory "private.el")))
        (when (file-exists-p private-file)
          (load-file private-file)))))
   #+END_SRC
   
** Packages

   Managing extensions for Emacs is simplified using =package= which is
   built in to Emacs 24 and newer. To load downloaded packages we need to
   initialize =package=. =cl= is a library that contains many functions from
   Common Lisp, and comes in handy quite often, so we want to make sure it's
   loaded, along with =package=, which is obviously needed.

   #+BEGIN_SRC emacs-lisp
   (require 'cl)
   (require 'package)
   (package-initialize)
   #+END_SRC
   
   Packages can be fetched from different mirrors, [[http://melpa.milkbox.net/#/][melpa]] is the largest
   archive and is well maintained.

   #+BEGIN_SRC emacs-lisp
   (setq package-archives
         '(("gnu" . "http://elpa.gnu.org/packages/")
           ("org" . "http://orgmode.org/elpa/")
           ("melpa" . "https://melpa.org/packages/")
           ("melpa-stable" . "https://stable.melpa.org/packages/")
           ("marmalade" . "https://marmalade-repo.org/packages/")))

   (add-to-list 'package-pinned-packages '(cider . "melpa-stable") t)
   #+END_SRC


   The configuration assumes that the packages listed below are
   installed. To ensure we install missing packages if they are missing.

   #+BEGIN_SRC emacs-lisp
   (let* ((packages
           '(airline-themes          ; Airline theme
             all-the-icons           ; A library for inserting Developer icons
             auto-compile            ; automatically compile Emacs Lisp libraries
             cider                   ; Clojure Interactive Development Environment
             company                 ; Modular text completion framework
             company-ansible         ; Anaconda backend for company-mode
             company-cmake           ; company-mode completion back-end for CMake
             company-flx             ; flx hooks for company
             company-irony           ; irony hooks for company
             company-irony-c-headers ; irony-headers hooks for compay
             company-jedi            ; company-mode completion back-end for Python JEDI
             company-go              ; company-mode backend for Go (using gocode)
             company-rtags           ; RTags backend for company
             company-statistics      ; Sort candidates using completion history.
             cmake-font-lock         ; Advanced, type aware, highlight support for CMake
             cmake-ide               ; cmake IDE integration
             cmake-mode              ; cmake editing mode
             cuda-mode               ; NVIDIA CUDA editing mode
             define-word             ; display the definition of word at point
             demangle-mode           ; Automatically demangle C++ symbols
             diminish                ; Diminished modes from modeline
             dired+                  ; Extensions to Dired.
             dired-efap              ; Edit Filename At Point in a dired buffer
             duplicate-thing         ; Duplicate current line & selection
             drag-stuff              ; Drag stuff around in Emacs
             elpy                    ; On-the-fly syntax checking
             eredis                  ; eredis, a Redis client in emacs lisp
             expand-region           ; Increase selected region by semantic units
             f                       ; Modern API for working with files and directories
             flycheck                ; On-the-fly syntax checking
             flycheck-irony          ; Flycheck: C/C++ support via Irony
             flycheck-pyflakes       ; Support pyflakes in flycheck
             flycheck-rtags          ; RTags Flycheck integration
             flymake-puppet          ; An Emacs flymake handler for syntax-checking puppet using puppet-lint
             focus                   ; Dim color of text in surrounding sections
             idle-require            ; load elisp libraries while Emacs is idle
             irony                   ; C/C++ minor mode powered by libclang
             geiser                  ; GNU Emacs and Scheme talk to each other
             git-gutter-fringe       ; Fringe version of git-gutter.el
             golden-ratio            ; Automatic resizing windows to golden ratio
             haskell-mode            ; A Haskell editing mode
             helm                    ; Incremental and narrowing framework
             helm-c-yasnippet        ; helm source for yasnippet.el
             helm-company            ; Helm interface for company-mode
             helm-flycheck           ; Show flycheck errors with helm
             helm-flx                ; Sort helm candidates by flx score
             helm-projectile         ; Helm integration for Projectile
             helm-swoop              ; Efficiently hopping squeezed lines
             helm-rtags              ; A front-end for rtags
             jedi-core               ; Common code of jedi.el and company-jedi.el
             js2-mode                ; Improved JavaScript editing mode
             json-mode               ; Major mode for editing JSON files
             magit                   ; control Git from Emacs
             magit-filenotify        ; Refresh status buffer when git tree changes
             magit-lfs               ; This plugin is magit integrated frontend for Git LFS
             markdown-mode           ; Emacs Major mode for Markdown-formatted files
             material-theme          ; A Theme based on Google Material Design
             move-text               ; Move current line or region with M-up or M-down.
             multiple-cursors        ; Multiple cursors for Emacs
             neotree                 ; A tree plugin like NerdTree for Vim
             olivetti                ; Minor mode for a nice writing environment
             org                     ; Outline-based notes management and organizer
             org-projectile          ; Repository todo management for org-mode
             origami                 ; Flexible text folding.
             paredit                 ; minor mode for editing parentheses
             pdf-tools               ; Emacs support library for PDF files
             powerline               ; Rewrite of powerline
             projectile              ; Manage and navigate projects in Emacs easily
             puppet-mode             ; Major mode for Puppet manifests
             rtags                   ; A front-end for rtags
             s                       ; The long lost Emacs string manipulation library.
             smart-mode-line         ; A color coded smart mode-line.
             spacemacs-theme         ; Color theme with a dark and light versions
             transpose-frame         ; Transpose windows arrangement in a frame
             try                     ; Try out Emacs packages
             undo-tree               ; Treat undo history as a tree
             use-package             ; A use-package declaration for simplifying your .emacs
             yasnippet               ; Yet another snippet extension for Emacs.
             yaml-mode               ; Major mode for editing YAML files

             ;; Remove all packages already installed
             (packages (remove-if 'package-installed-p packages))
             (when packages
               (ignore-errors 
                 (package-refresh-contents)
                 (mapcar 'package-install packages)
                 ;; This package is only relevant for Mac OS X.
                 (if (eq system-type 'darwin)
                     (package-install 'exec-path-from-shell)))))))
     )
   #+END_SRC
   
** Mac OS X

   I run this configuration mostly on Mac OS X, so we need a couple of
   settings to make things work smoothly. In the package section
   =exec-path-from-shell= is included (only if you're running OS X), this is
   to include environment-variables from the shell. It makes using Emacs
   along with external processes a lot simpler. I also prefer using the
   =Command=-key as the =Meta=-key.

   #+BEGIN_SRC emacs-lisp
   (when (eq system-type 'darwin)
     (setq ns-pop-up-frames nil
           mac-option-modifier nil
           mac-command-modifier 'meta
           select-enable-clipboard t)
     (exec-path-from-shell-initialize))
   #+END_SRC

** Require

   Some features are not loaded by default to minimize initialization time,
   so they have to be required (or loaded, if you will). =require=-calls
   tends to lead to the largest bottleneck's in a
   configuration. =idle-require= delays the =require=-calls to a time where
   Emacs is in idle. So this is great for stuff you eventually want to load,
   but is not a high priority.

   #+BEGIN_SRC emacs-lisp
   (require 'idle-require)             ; Need in order to use idle-require

   (use-package yasnippet
     :ensure t)

   (use-package company-statistics
     :ensure t
     :init
     (add-hook 'after-init-hook 'company-statistics-mode))

   (use-package origami
     :ensure t
     :init
     (global-origami-mode t))

   (use-package neotree
     :ensure t)
   ;; :config
   ;; (setq projectile-switch-project-action 'neotree-projectile-action))

   (dolist (feature
            '(auto-compile             ; auto-compile .el files
              matlab                   ; matlab-mode
              ob-matlab                ; org-babel matlab
              ox-latex                 ; the latex-exporter (from org)
              ox-md                    ; Markdown exporter (from org)
              recentf                  ; recently opened files
              tex-mode                 ; TeX, LaTeX, and SliTeX mode commands
              ))
     (idle-require feature))

   (setq idle-require-idle-delay 2)
   (idle-require-mode 1)
    #+END_SRC
   
** Sane defaults

   These are what /I/ consider to be saner defaults.

   We can set variables to whatever value we'd like using =setq=.

   #+BEGIN_SRC emacs-lisp
   (setq auto-revert-interval 1            ; Refresh buffers fast
         custom-file (make-temp-file "")   ; Discard customization's
         default-input-method "TeX"        ; Use TeX when toggling input method
         echo-keystrokes 0.1               ; Show keystrokes asap
         inhibit-startup-message t         ; No splash screen please
         initial-scratch-message nil       ; Clean scratch buffer
         recentf-max-saved-items 100       ; Show more recent files
         ring-bell-function 'ignore        ; Quiet
         sentence-end-double-space nil)    ; No double space
   ;; Some mac-bindings interfere with Emacs bindings.
   (when (boundp 'mac-pass-command-to-system)
     (setq mac-pass-command-to-system nil))
   #+END_SRC

   Some variables are buffer-local, so changing them using =setq= will only
   change them in a single buffer. Using =setq-default= we change the
   buffer-local variable's default value.

   #+BEGIN_SRC emacs-lisp
   (setq-default fill-column 119                   ; Maximum line width
                 truncate-lines t                  ; Don't fold lines
                 indent-tabs-mode nil              ; Use spaces instead of tabs
                 split-width-threshold 100         ; Split verticly by default
                 auto-fill-function 'do-auto-fill) ; Auto-fill-mode everywhere
   #+END_SRC

   The =load-path= specifies where Emacs should look for =.el=-files (or
   Emacs lisp files). I have a directory called =site-lisp= where I keep all
   extensions that have been installed manually (these are mostly my own
   projects).

   #+BEGIN_SRC emacs-lisp
   (let ((default-directory (concat user-emacs-directory "site-lisp/")))
     (when (file-exists-p default-directory)
       (setq load-path
             (append
              (let ((load-path (copy-sequence load-path)))
                (normal-top-level-add-subdirs-to-load-path)) load-path))))
   #+END_SRC

   Answering /yes/ and /no/ to each question from Emacs can be tedious, a
   single /y/ or /n/ will suffice.

   #+BEGIN_SRC emacs-lisp
   (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

   To avoid file system clutter we put all auto saved files in a single
   directory.

   #+BEGIN_SRC emacs-lisp
   (defvar emacs-autosave-directory
     (concat user-emacs-directory "autosaves/")
     "This variable dictates where to put auto saves. It is set to a
     directory called autosaves located wherever your .emacs.d/ is
     located.")

   ;; Sets all files to be backed up and auto saved in a single directory.
   (setq backup-directory-alist
         `((".*" . ,emacs-autosave-directory))
         auto-save-file-name-transforms
         `((".*" ,emacs-autosave-directory t)))
   #+END_SRC

   Set =utf-8= as preferred coding system.

   #+BEGIN_SRC emacs-lisp
   (set-language-environment "UTF-8")
   #+END_SRC

   By default the =narrow-to-region= command is disabled and issues a
   warning, because it might confuse new users. I find it useful sometimes,
   and don't want to be warned.

   #+BEGIN_SRC emacs-lisp
   (put 'narrow-to-region 'disabled nil)
   #+END_SRC

   Automaticly revert =doc-view=-buffers when the file changes on disk.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'doc-view-mode-hook 'auto-revert-mode)
   #+END_SRC

** Modes
   
   There are some modes that are enabled by default that I don't find
   particularly useful. We create a list of these modes, and disable all of
   these.

   #+BEGIN_SRC emacs-lisp
   (dolist (mode
            '(tool-bar-mode                ; No toolbars, more room for text
              scroll-bar-mode              ; No scroll bars either
              blink-cursor-mode))          ; The blinking cursor gets old
     (funcall mode 0))
   #+END_SRC

   Let's apply the same technique for enabling modes that are disabled by
   default.

   #+BEGIN_SRC emacs-lisp
   (dolist (mode
            '(abbrev-mode                  ; E.g. sopl -> System.out.println
              column-number-mode           ; Show column number in mode line
              delete-selection-mode        ; Replace selected text
              dirtrack-mode                ; directory tracking in *shell*
              drag-stuff-global-mode       ; Drag stuff around
              global-company-mode          ; Auto-completion everywhere
              global-git-gutter-mode       ; Show changes latest commit
              global-prettify-symbols-mode ; Greek letters should look greek
              golden-ratio-mode            ; Automatic resizing of windows
              projectile-global-mode       ; Manage and navigate projects
              recentf-mode                 ; Recently opened files
              yas-global-mode              ; Enable yasnippet
              show-paren-mode))            ; Highlight matching parentheses

     (funcall mode 1))

   (add-hook 'after-init-hook 'global-company-mode)
   (setq projectile-completion-system 'helm)
   (when (version< emacs-version "24.4")
     (eval-after-load 'auto-compile
       '((auto-compile-on-save-mode 1))))  ; compile .el files on save
   #+END_SRC

** Visuals
   
   Initialize the powerline with powerline-center
   Change the color-theme to =spacemacs-dark=. Since I love me some darker 
   themes. 

   #+BEGIN_SRC emacs-lisp
   (require 'airline-themes)
   (load-theme 'airline-solarized-alternate-gui t)
   (load-theme 'spacemacs-dark t)
   (powerline-center-theme)
   #+END_SRC

   =leuven= is my preferred light theme, but =monokai= makes a very nice
   dark theme. I want to be able to cycle between these.

   #+BEGIN_SRC emacs-lisp
   (defun cycle-themes ()
     "Returns a function that lets you cycle your themes."
     (lexical-let ((themes '#1=(leuven spacemacs-dark . #1#)))
       (lambda ()
         (interactive)
         ;; Rotates the thme cycle and changes the current theme.
         (load-theme (car (setq themes (cdr themes))) t))))
   #+END_SRC

   Use the [[http://www.levien.com/type/myfonts/inconsolata.html][Inconsolata]] font if it's installed on the system.

   #+BEGIN_SRC emacs-lisp
   (cond ((member "Source Code Pro" (font-family-list))
          (set-face-attribute 'default nil :font "Source Code Pro-11"))
         ((member "Inconsolata" (font-family-list))
          (set-face-attribute 'default nil :font "Inconsolata-14")))
   #+END_SRC

   [[http://www.eskimo.com/~seldon/diminish.el][diminish.el]] allows you to hide or abbreviate their presence in the
   modeline. I rarely look at the modeline to find out what minor-modes are
   enabled, so I disable every global minor-mode, and some for lisp editing.

   To ensure that the mode is loaded before diminish it, we should use
   ~with-eval-after-load~. To avoid typing this multiple times a small macro
   is provided.

   #+BEGIN_SRC emacs-lisp
   (defmacro safe-diminish (file mode &optional new-name)
     `(with-eval-after-load ,file
        (diminish ,mode ,new-name)))

   (diminish 'auto-fill-function)
   (safe-diminish "eldoc" 'eldoc-mode)
   (safe-diminish "flyspell" 'flyspell-mode)
   (safe-diminish "helm-mode" 'helm-mode)
   (safe-diminish "projectile" 'projectile-mode)
   (safe-diminish "golden-ratio" 'golden-ratio-mode)
   (safe-diminish "paredit" 'paredit-mode "()")
   #+END_SRC

   Truncate the name of the buffer is a nice feature since a lot of buffers
   can have somewhat of the same name.

   #+BEGIN_SRC emacs-lisp
   (setq uniquify-buffer-name-style 'forward)
   (setq uniquify-separator "/")
   (setq uniquify-after-kill-buffer-p t)
   (setq uniquify-ignore-buffers-re "^\\*")
   #+END_SRC


   [[https://github.com/syohex/emacs-git-gutter-fringe][git-gutter-fringe]] gives a great visual indication of where you've made
   changes since your last commit. There are several packages that performs
   this task; the reason I've ended up with =git-gutter-fringe= is that it
   reuses the (already present) fringe, saving a tiny bit of screen-estate.

   I smuggled some configurations from [[https://github.com/torenord/.emacs.d/][torenord]], providing a cleaner look.

   #+BEGIN_SRC emacs-lisp
   (require 'git-gutter-fringe)

   (dolist (p '((git-gutter:added    . "#0c0")
                (git-gutter:deleted  . "#c00")
                (git-gutter:modified . "#c0c")))
     (set-face-foreground (car p) (cdr p))
     (set-face-background (car p) (cdr p)))
   #+END_SRC

   Having line numbers in all buffers and windows is one thing I can't live 
   without anymore.

   #+BEGIN_SRC emacs-lisp
   (global-linum-mode t)
   #+END_SRC


   New in Emacs 24.4 is the =prettify-symbols-mode=! It's neat.

   #+BEGIN_SRC emacs-lisp
   (setq-default prettify-symbols-alist '(("lambda" . ?λ)
                                          ("delta" . ?Δ)
                                          ("gamma" . ?Γ)
                                          ("phi" . ?φ)
                                          ("psi" . ?ψ)))
   (setq powerline-utf-8-separator-left        #xe0b0
         powerline-utf-8-separator-right       #xe0b2
         airline-utf-glyph-separator-left      #xe0b0
         airline-utf-glyph-separator-right     #xe0b2
         airline-utf-glyph-subseparator-left   #xe0b1
         airline-utf-glyph-subseparator-right  #xe0b3
         airline-utf-glyph-branch              #xe0a0
         airline-utf-glyph-readonly            #xe0a2
         airline-utf-glyph-linenumber          #xe0a1)
   #+END_SRC
** PDF Tools
  
   [[https://github.com/politza/pdf-tools][PDF Tools]] makes a huge improvement on the built-in [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Document-View.html][doc-view-mode]]; the only
   drawback is the =pdf-tools-install= (which has to be executed before the
   package can be used) takes a couple of /seconds/ to execute. Instead of
   running it at init-time, we'll run it whenever a PDF is opened. Note that
   it's only slow on the first run!

   #+BEGIN_SRC emacs-lisp
   (add-hook 'pdf-tools-enabled-hook 'auto-revert-mode)
   (add-to-list 'auto-mode-alist '("\\.pdf\\'" . pdf-tools-install))
   #+END_SRC

** Completion

   [[https://github.com/auto-complete/auto-complete][Auto-Complete]] has been a part of my config for years, but I want to try
   out [[http://company-mode.github.io/][company-mode]]. If I code in an environment with good completion, I've
   made an habit of trying to /guess/ function-names, and looking at the
   completions for the right one. So I want a pretty aggressive completion
   system, hence the no delay settings and short prefix length.

   #+BEGIN_SRC emacs-lisp
   (setq company-idle-delay 0
         company-echo-delay 0
         company-dabbrev-downcase nil
         company-minimum-prefix-length 2
         company-selection-wrap-around t
         company-transformers '(company-sort-by-occurrence
                                company-sort-by-backend-importance))
   #+END_SRC
   
   Yasnippet is one of those things that I customize a lot so I have another
   repository of them snippets under VCS. 

   #+BEGIN_SRC emacs-lisp
   (setq yas-snippet-dirs '(concat user-emacs-directory "snippets"))
   #+END_SRC

** Helm
   I've been a long time user of ~ido-mode~ along with ~ido-vertical-mode~, and
   don't have any particular complaints. Though I've got a feeling I'm missing
   out on something by not using [[https://github.com/emacs-helm/helm][helm]]. I will [[http://tuhdo.github.io/helm-intro.html][this excellent tutorial]] as a
   starting point, along with some of the suggested configurations.

   ~helm~ has a wonderful feature, being able to grep files by ~C-s~ anywhere,
   which is useful. [[http://beyondgrep.com/][ack]] is a great ~grep~-replacement, and is designed to
   search source code, so I want to use that if it's available.

   Note that some changes in bindings are located in the key bindings (found
   near the end of the configuration).

   #+BEGIN_SRC emacs-lisp
   (require 'helm)
   (require 'helm-config)

   (setq helm-split-window-in-side-p t
         helm-M-x-fuzzy-match t
         helm-buffers-fuzzy-matching t
         helm-recentf-fuzzy-match t
         helm-move-to-line-cycle-in-source t
         projectile-completion-system 'helm)

   (when (executable-find "ack")
     (setq helm-grep-default-command
           "ack -Hn --no-group --no-color %e %p %f"
           helm-grep-default-recurse-command
           "ack -H --no-group --no-color %e %p %f"))

   (set-face-attribute 'helm-selection nil :background "cyan")

   (helm-mode 1)
   (helm-projectile-on)
   (helm-adaptive-mode 1)
   #+END_SRC
** Calendar

   Define a function to display week numbers in =calender-mode=. The snippet
   is from [[http://www.emacswiki.org/emacs/CalendarWeekNumbers][EmacsWiki]].

   #+BEGIN_SRC emacs-lisp
   (defun calendar-show-week (arg)
     "Displaying week number in calendar-mode."
     (interactive "P")
     (copy-face font-lock-constant-face 'calendar-iso-week-face)
     (set-face-attribute
      'calendar-iso-week-face nil :height 0.7)
     (setq calendar-intermonth-text
           (and arg
                '(propertize
                  (format
                   "%2d"
                   (car (calendar-iso-from-absolute
                         (calendar-absolute-from-gregorian
                          (list month day year)))))
                  'font-lock-face 'calendar-iso-week-face))))
   #+END_SRC

   Evaluate the =calendar-show-week= function.

   #+BEGIN_SRC emacs-lisp
   (calendar-show-week t)
   #+END_SRC

   Set Monday as the first day of the week, and set my location.

   #+BEGIN_SRC emacs-lisp
   (setq calendar-week-start-day 1
         calendar-latitude 59.3
         calendar-longitude 18.0
         calendar-location-name "Stockholm, Sweden")
   #+END_SRC

** Flyspell

   Flyspell offers on-the-fly spell checking. We can enable flyspell for all
   text-modes with this snippet.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'text-mode-hook 'turn-on-flyspell)
   #+END_SRC

   To use flyspell for programming there is =flyspell-prog-mode=, that only
   enables spell checking for comments and strings. We can enable it for all
   programming modes using the =prog-mode-hook=.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'prog-mode-hook 'flyspell-prog-mode)
   #+END_SRC

   Since ISpell hasn't been updated since 2011 I will tell flyspell to useful
   aspell instead and it should still work everything as normal anyway

   #+BEGIN_SRC emacs-lisp
   (setq ispell-program-name "aspell")
   #+END_SRC

   
   When working with several languages, we should be able to cycle through
   the languages we most frequently use. Every buffer should have a separate
   cycle of languages, so that cycling in one buffer does not change the
   state in a different buffer (this problem occurs if you only have one
   global cycle). We can implement this by using a [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Closures.html][closure]].

   #+BEGIN_SRC emacs-lisp
   (defun cycle-languages ()
     "Changes the ispell dictionary to the first element in
   ISPELL-LANGUAGES, and returns an interactive function that cycles
   the languages in ISPELL-LANGUAGES when invoked."
     (lexical-let ((ispell-languages '#1=("english" "svenska" . #1#)))
       (ispell-change-dictionary (car ispell-languages))
       (lambda ()
         (interactive)
         ;; Rotates the languages cycle and changes the ispell dictionary.
         (ispell-change-dictionary
          (car (setq ispell-languages (cdr ispell-languages)))))))
   #+END_SRC

   =flyspell= signals an error if there is no spell-checking tool is
   installed. We can advice =turn-on-flyspell= and =flyspell-prog-mode= to
   only try to enable =flyspell= if a spell-checking tool is available. Also
   we want to enable cycling the languages by typing =C-c l=, so we bind the
   function returned from =cycle-languages=.

   #+BEGIN_SRC emacs-lisp
   (defadvice turn-on-flyspell (before check nil activate)
     "Turns on flyspell only if a spell-checking tool is installed."
     (when (executable-find ispell-program-name)
       (local-set-key (kbd "C-c l") (cycle-languages))))
   #+END_SRC

** Org
   I use =org-agenda= along with =org-capture= for appointments and such.

   #+BEGIN_SRC emacs-lisp
   (setq org-agenda-files '("~/drive/emacs/agenda.org")  ; A list of agenda files
         org-agenda-default-appointment-duration 120 ; 2 hours appointments
         org-capture-templates                       ; Template for adding tasks
         '(("t" "Tasks" entry (file+headline "~/drive/emacs/agenda.org" "Tasks")
            "** TODO %?" :prepend t)
           ("m" "Master" entry (file+olp "~/drive/emacs/agenda.org" "Oppgaver" "Master")
            "*** TODO %?" :prepend t)
           ("a" "Deals" entry (file+headline "~/drive/emacs/agenda.org" "Deals")
            "** %?\n   SCHEDULED: %T" :prepend t)))
   #+END_SRC

   When editing org-files with source-blocks, we want the source blocks to
   be themed as they would in their native mode.

   #+BEGIN_SRC emacs-lisp
   (setq org-src-fontify-natively t
         org-src-tab-acts-natively t
         org-confirm-babel-evaluate nil
         org-edit-src-content-indentation 0)
   #+END_SRC

   This is quite an ugly fix for allowing code markup for expressions like
   ="this string"=, because the quotation marks causes problems.

   #+BEGIN_SRC emacs-lisp
   ;;(require 'org)
   (eval-after-load "org"
     '(progn
        (setcar (nthcdr 2 org-emphasis-regexp-components) " \t\n,")
        (custom-set-variables `(org-emphasis-alist ',org-emphasis-alist))))
   #+END_SRC

** RTags

   Rtags is a great code static analyzer (sorta)
   it gives many features to the c++ toolkit

   #+BEGIN_SRC emacs-lisp
   (require 'irony)
   (require 'rtags)
   (require 'company-irony)
   (require 'company-rtags)
   (require 'helm-rtags)
   (require 'flycheck-rtags)

   (setq rtags-completions-enabled t)
   (push 'company-rtags company-backends)      
   (setq rtags-autostart-diagnostics t)
   (rtags-enable-standard-keybindings)

   (defun flycheck-rtags-usage-setup ()
     (flycheck-select-checker 'rtags)
     (setq-local flycheck-highlighting-mode nil)
     (setq-local flycheck-check-syntax-automatically nil))
   (add-hook 'c-mode-common-hook #'flycheck-rtags-usage-setup)
   (eval-after-load 'flycheck
     '(add-hook 'flycheck-mode-hook #'flycheck-irony-setup))
   #+END_SRC

** CMake-IDE
   
   I use the brilliant cmake-ide to auto-generate code from 
   current project and feed it to rtags ans such things.

   #+BEGIN_SRC emacs-lisp
   (cmake-ide-setup)
   #+END_SRC

** Yasnippet

   I have some small snippets that I made my self and i need them on all systems

#+BEGIN_SRC emacs-lisp
(setq yas-snippet-dirs
      '("~/.emacs.d/snippets"
        "~/.emacs.d/custom-snippets"))
#+END_SRC

** Interactive functions
   <<sec:defuns>>

   =just-one-space= removes all whitespace around a point - giving it a
   negative argument it removes newlines as well. We wrap a interactive
   function around it to be able to bind it to a key. In Emacs 24.4
   =cycle-spacing= was introduced, and it works like =just-one-space=, but
   when run in succession it cycles between one, zero and the original
   number of spaces.

   #+BEGIN_SRC emacs-lisp
   (defun cycle-spacing-delete-newlines ()
     "Removes whitespace before and after the point."
     (interactive)
     (if (version< emacs-version "24.4")
         (just-one-space -1)
       (cycle-spacing -1)))
   #+END_SRC

   Often I want to find other occurrences of a word I'm at, or more
   specifically the symbol (or tag) I'm at. The
   =isearch-forward-symbol-at-point= in Emacs 24.4 works well for this, but
   I don't want to be bothered with the =isearch= interface. Rather jump
   quickly between occurrences of a symbol, or if non is found, don't do
   anything.

   #+BEGIN_SRC emacs-lisp
   (defun jump-to-symbol-internal (&optional backwardp)
     "Jumps to the next symbol near the point if such a symbol
   exists. If BACKWARDP is non-nil it jumps backward."
     (let* ((point (point))
            (bounds (find-tag-default-bounds))
            (beg (car bounds)) (end (cdr bounds))
            (str (isearch-symbol-regexp (find-tag-default)))
            (search (if backwardp 'search-backward-regexp
                      'search-forward-regexp)))
       (goto-char (if backwardp beg end))
       (funcall search str nil t)
       (cond ((<= beg (point) end) (goto-char point))
             (backwardp (forward-char (- point beg)))
             (t  (backward-char (- end point))))))

   (defun jump-to-previous-like-this ()
     "Jumps to the previous occurrence of the symbol at point."
     (interactive)
     (jump-to-symbol-internal t))

   (defun jump-to-next-like-this ()
     "Jumps to the next occurrence of the symbol at point."
     (interactive)
     (jump-to-symbol-internal))
   #+END_SRC

   Getting and setting the time and timestamp is something that is useful most
   of the time... This can be used in more than one occasion.

   #+BEGIN_SRC emacs-lisp
   (defun date (arg)
     (interactive "P")
     (insert (if arg
                 (format-time-string "%d.%m.%Y")
               (format-time-string "%Y-%m-%d"))))

   (defun timestamp ()
     (interactive)
     (insert (format-time-string "%Y-%m-%dT%H:%M:%S"))) 
   #+END_SRC



   Switching back and forth between two buffers is something that I can find
   my self do quite a lot. So to speed that up there was a need for a quick 
   swap thing.

   #+BEGIN_SRC emacs-lisp
   (defun switch-to-previous-buffer ()
     "Switch to previously open buffer.Repeated invocations toggle between the two most recently open buffers."
     (interactive)
     (switch-to-buffer (other-buffer (current-buffer) 1)))
   #+END_SRC


   I sometimes regret killing the =*scratch*=-buffer, and have realized I
   never want to actually kill it. I just want to get it out of the way, and
   clean it up. The function below does just this for the
   =*scratch*=-buffer, and works like =kill-this-buffer= for any other
   buffer. It removes all buffer content and buries the buffer (this means
   making it the least likely candidate for =other-buffer=).

   #+BEGIN_SRC emacs-lisp
   (defun kill-this-buffer-unless-scratch ()
     "Works like `kill-this-buffer' unless the current buffer is the
   ,*scratch* buffer. In witch case the buffer content is deleted and
   the buffer is buried."
     (interactive)
     (if (not (string= (buffer-name) "*scratch*"))
         (kill-this-buffer)
       (delete-region (point-min) (point-max))
       (switch-to-buffer (other-buffer))
       (bury-buffer "*scratch*")))
   #+END_SRC

   To duplicate either selected text or a line we define this interactive
   function.

   #+BEGIN_SRC emacs-lisp
   (defun duplicate-thing (comment)
     "Duplicates the current line, or the region if active. If an argument is
   given, the duplicated region will be commented out."
     (interactive "P")
     (save-excursion
       (let ((start (if (region-active-p) (region-beginning) (point-at-bol)))
             (end   (if (region-active-p) (region-end) (point-at-eol))))
         (goto-char end)
         (unless (region-active-p)
           (newline))
         (insert (buffer-substring start end))
         (when comment (comment-region start end)))))
   #+END_SRC

   To tidy up a buffer we define this function borrowed from [[https://github.com/simenheg][simenheg]].

   #+BEGIN_SRC emacs-lisp
   (defun tidy ()
     "Ident, untabify and unwhitespacify current buffer, or region if active."
     (interactive)
     (let ((beg (if (region-active-p) (region-beginning) (point-min)))
           (end (if (region-active-p) (region-end) (point-max))))
       (indent-region beg end)
       (whitespace-cleanup)
       (untabify beg (if (< end (point-max)) end (point-max)))))
   #+END_SRC

   Org mode does currently not support synctex (which enables you to jump from
   a point in your TeX-file to the corresponding point in the pdf), and it
   [[http://comments.gmane.org/gmane.emacs.orgmode/69454][seems like a tricky problem]].

   Calling this function from an org-buffer jumps to the corresponding section
   in the exported pdf (given that the pdf-file exists), using pdf-tools.

   #+BEGIN_SRC emacs-lisp
   (defun org-sync-pdf ()
     (interactive)
     (let ((headline (nth 4 (org-heading-components)))
           (pdf (concat (file-name-base (buffer-name)) ".pdf")))
       (when (file-exists-p pdf)
         (find-file-other-window pdf)
         (pdf-links-action-perform
          (cl-find headline (pdf-info-outline pdf)
                   :key (lambda (alist) (cdr (assoc 'title alist)))
                   :test 'string-equal)))))
   #+END_SRC

** Advice
   An advice can be given to a function to make it behave differently. This
   advice makes =eval-last-sexp= (bound to =C-x C-e=) replace the sexp with
   the value.

   #+BEGIN_SRC emacs-lisp
   (defadvice eval-last-sexp (around replace-sexp (arg) activate)
     "Replace sexp when called with a prefix argument."
     (if arg
         (let ((pos (point)))
           ad-do-it
           (goto-char pos)
           (backward-kill-sexp)
           (forward-sexp))
       ad-do-it))
   #+END_SRC

   The undo stack can sometimes be a bit overwhelming so I found this neat 
   undo-tree which helps me organize it better

   #+BEGIN_SRC emacs-lisp
   (defadvice undo-tree-undo (around keep-region activate)
     (if (use-region-p)
         (let ((m (set-marker (make-marker) (mark)))
               (p (set-marker (make-marker) (point))))
           ad-do-it
           (goto-char p)
           (set-mark m)
           (set-marker p nil)
           (set-marker m nil))
       ad-do-it))
   #+END_SRC

   When interactively changing the theme (using =M-x load-theme=), the
   current custom theme is not disabled. This often gives weird-looking
   results; we can advice =load-theme= to always disable themes currently
   enabled themes.

   #+BEGIN_SRC emacs-lisp
   (defadvice load-theme
       (before disable-before-load (theme &optional no-confirm no-enable) activate)
     (mapc 'disable-theme custom-enabled-themes))
   #+END_SRC

** global-scale-mode

   These functions provide something close to ~text-scale-mode~, but for every
   buffer, including the minibuffer and mode line.

   #+BEGIN_SRC emacs-lisp
   (lexical-let* ((default (face-attribute 'default :height))
                  (size default))

     (defun global-scale-default ()
       (interactive)
       (setq size default)
       (global-scale-internal size))

     (defun global-scale-up ()
       (interactive)
       (global-scale-internal (incf size 20)))

     (defun global-scale-down ()
       (interactive)
       (global-scale-internal (decf size 20)))

     (defun global-scale-internal (arg)
       (set-face-attribute 'default (selected-frame) :height arg)
       (set-transient-map
        (let ((map (make-sparse-keymap)))
          (global-set-key "emacs-C-=" 'global-scale-default)
          (global-set-key "emacs-C-+" 'global-scale-up)
          (global-set-key "emacs-C--" 'global-scale-down)
          ;; (define-key map (kbd "C-=") 'global-scale-up)
          ;; (define-key map (kbd "C-+") 'global-scale-up)
          ;; (define-key map (kbd "C--") 'global-scale-down)
          ;; (define-key map (kbd "C-0") 'global-scale-default)
          map))))
   #+END_SRC
   
* Mode specific
** Shell

   I use =shell= whenever i want to use access the command line in Emacs. I
   keep a symlink between my =~/.bash_profile= (because I run OS X) and
   =~/.emacs_bash=, to make the transition between my standard terminal and
   the shell as small as possible. To be able to quickly switch back and
   forth between a shell I make use of this little function.

   #+BEGIN_SRC emacs-lisp
   (defun toggle-shell ()
     "Jumps to eshell or back."
     (interactive)
     (if (string= (buffer-name) "*shell*")
         (switch-to-prev-buffer)
       (shell)))
   #+END_SRC

   I'd like the =C-l= to work more like the standard terminal (which works
   like running =clear=), and resolve this by simply removing the
   buffer-content. Mind that this is not how =clear= works, it simply adds a
   bunch of newlines, and puts the prompt at the top of the window, so it
   does not remove anything. In Emacs removing stuff is less of a worry,
   since we can always undo!

   #+BEGIN_SRC emacs-lisp
   (defun clear-comint ()
     "Runs `comint-truncate-buffer' with the
   `comint-buffer-maximum-size' set to zero."
     (interactive)
     (let ((comint-buffer-maximum-size 0))
       (comint-truncate-buffer)))
   #+END_SRC

   Lastly we should bind our functions. The =toggle-shell= should be a
   global binding (because we want to be able to switch to a shell from any
   buffer), but the =clear-shell= should only affect =shell-mode=.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'comint-mode-hook (lambda () (local-set-key (kbd "C-l") 'clear-comint)))
   #+END_SRC

** Lisp

   I use =Paredit= when editing lisp code, we enable this for all lisp-modes.

   #+BEGIN_SRC emacs-lisp
   (dolist (mode '(cider-repl-mode
                   clojure-mode
                   ielm-mode
                   geiser-repl-mode
                   slime-repl-mode
                   lisp-mode
                   emacs-lisp-mode
                   lisp-interaction-mode
                   scheme-mode))
     ;; add paredit-mode to all mode-hooks
     (add-hook (intern (concat (symbol-name mode) "-hook")) 'paredit-mode))
   #+END_SRC

*** Emacs Lisp

    In =emacs-lisp-mode= we can enable =eldoc-mode= to display information
    about a function or a variable in the echo area.

    #+BEGIN_SRC emacs-lisp
    (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    #+END_SRC

*** Common lisp

    I use [[http://www.common-lisp.net/project/slime/][Slime]] along with =lisp-mode= to edit Common Lisp code. Slime
    provides code evaluation and other great features, a must have for a
    Common Lisp developer. [[http://www.quicklisp.org/beta/][Quicklisp]] is a library manager for Common Lisp,
    and you can install Slime following the instructions from the site along
    with this snippet.

    #+BEGIN_SRC emacs-lisp
    (defun activate-slime-helper ()
      (when (file-exists-p "~/.quicklisp/slime-helper.el")
        (load (expand-file-name "~/.quicklisp/slime-helper.el"))
        (define-key slime-repl-mode-map (kbd "C-l")
          'slime-repl-clear-buffer))
      (remove-hook 'lisp-mode-hook #'activate-slime-helper))

    (add-hook 'lisp-mode-hook #'activate-slime-helper)
    #+END_SRC

    We can specify what Common Lisp program Slime should use (I use SBCL).

    #+BEGIN_SRC emacs-lisp
    (setq inferior-lisp-program "sbcl")
    #+END_SRC

    More sensible =loop= indentation, borrowed from [[https://github.com/simenheg][simenheg]].

    #+BEGIN_SRC emacs-lisp
    (setq lisp-loop-forms-indentation   6
          lisp-simple-loop-indentation  2
          lisp-loop-keyword-indentation 6)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp

    #+END_SRC

*** Scheme

    [[http://www.nongnu.org/geiser/][Geiser]] provides features similar to Slime for Scheme editing. Everything
    works pretty much out of the box, we only need to add auto completion,
    and specify which scheme-interpreter we prefer.

    #+BEGIN_SRC emacs-lisp
    (eval-after-load "geiser"
      '(setq geiser-active-implementations '(guile)))
    #+END_SRC

** C and C++

   The =c-mode-common-hook= is a general hook that work on all C-like
   languages (C, C++, Java, etc...). I like being able to quickly compile
   using =C-c C-c= (instead of =M-x compile=), a habit from =latex-mode=.

   #+BEGIN_SRC emacs-lisp
   (defun c-setup ()
     (local-set-key (kbd "C-c C-c") 'compile))
   (add-hook 'c-mode-common-hook 'c-setup)
   #+END_SRC

   There is as much debate about code styling as there is things about 
   where everything should live. But here are my preferences as I like them.

   #+BEGIN_SRC emacs-lisp
   (defun c-argument-indent-hook () 
     (c-set-offset 'arglist-intro '+))

   (defun c-indentation-hook ()
     (c-set-offset 'substatement-open 0)
     (setq c-tab-always-indent t)
     (setq c-basic-offset 4)
     (setq c-indent-level 4)
     (setq tab-stop-list '(2 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60))
     (setq tab-width 4)
     (setq indent-tabs-mode nil))

   (add-hook 'c-mode-common-hook 'c-indentation-hook)
   (add-hook 'c-mode-common-hook 'c-argument-indent-hook)
   #+END_SRC

   I find that I mostly does C++ and not as much C. Therefore I'm putting the
   .h and .cc files to c++-mode since most time that is what the code is written
   in.

   #+BEGIN_SRC emacs-lisp
   (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
   (add-to-list 'auto-mode-alist '("\\.cc\\'" . c++-mode))
   #+END_SRC


   I'm using irony to help me when coding in c++ 

   #+BEGIN_SRC emacs-lisp
      (add-hook 'c++-mode-hook 'irony-mode)
      (add-hook 'c-mode-hook 'irony-mode)
      (add-hook 'objc-mode-hook 'irony-mode)

   (defun c-irony-completion-hook () 
     (define-key irony-mode-map [remap completion-at-point] 'irony-completion-at-point-async)
     (define-key irony-mode-map [remap complete-symbol] 'irony-completion-at-point-async))

      (add-hook 'irony-mode-hook 'c-irony-completion-hook)
      (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
      (add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)

   (setq company-backends (delete 'company-semantic company-backends))
   (eval-after-load 'company
     '(add-to-list
       'company-backends 'company-irony))

   (setq company-idle-delay 0)
   (add-hook 'c++-mode-hook 'flycheck-mode)
   (add-hook 'c-mode-hook 'flycheck-mode)
   #+END_SRC

** CMake
   Here is all the specifics for cmake

   #+BEGIN_SRC emacs-lisp
   (require 'cmake-mode)
   (setq auto-mode-alist 
      (append 
       '(("CMakeLists\\.txt\\'" . cmake-mode))
       '(("\\.cmake\\'" . cmake-mode))
       auto-mode-alist))
   (autoload 'cmake-font-lock-activate "cmake-font-lock" nil t)
   (add-hook 'cmake-mode-hook 'cmake-font-lock-activate)
   #+END_SRC

** YAML

   Not all yaml extensions listens to the correct mode. So we need to tell
   emacs the correct mode to use.

   #+BEGIN_SRC emacs-lisp
   (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode))
   #+END_SRC

** Java
   Some statements in Java appear often, and become tedious to write
   out. We can use abbrevs to speed this up.

   #+BEGIN_SRC emacs-lisp
   (define-abbrev-table 'java-mode-abbrev-table
     '(("psv" "public static void main(String[] args) {" nil 0)
       ("sopl" "System.out.println" nil 0)
       ("sop" "System.out.printf" nil 0)))
   #+END_SRC

   To be able to use the abbrev table defined above, =abbrev-mode= must be
   activated.

   #+BEGIN_SRC emacs-lisp
   (defun java-setup ()
     (abbrev-mode t)
     (setq-local compile-command (concat "javac " (buffer-name))))

   (add-hook 'java-mode-hook 'java-setup)
   #+END_SRC

** LaTeX and org-mode LaTeX export

   =.tex=-files should be associated with =latex-mode= instead of
   =tex-mode=.

   #+BEGIN_SRC emacs-lisp
   (add-to-list 'auto-mode-alist '("\\.tex\\'" . latex-mode))
   #+END_SRC

   Use ~biblatex~ for bibliography.

   #+BEGIN_SRC emacs-lisp
   (setq-default bibtex-dialect 'biblatex)
   #+END_SRC

   I like using the [[https://code.google.com/p/minted/][Minted]] package for source blocks in LaTeX. To make org
   use this we add the following snippet.

   #+BEGIN_SRC emacs-lisp
   (eval-after-load 'org
     '(add-to-list 'org-latex-packages-alist '("" "minted")))
   (setq org-latex-listings 'minted)
   #+END_SRC

   Because [[https://code.google.com/p/minted/][Minted]] uses [[http://pygments.org][Pygments]] (an external process), we must add the
   =-shell-escape= option to the =org-latex-pdf-process= commands. The
   =tex-compile-commands= variable controls the default compile command for
   Tex- and LaTeX-mode, we can add the flag with a rather dirty statement
   (if anyone finds a nicer way to do this, please let me know).

   #+BEGIN_SRC emacs-lisp
   (eval-after-load 'tex-mode
     '(setcar (cdr (cddaar tex-compile-commands)) " -shell-escape "))
   #+END_SRC

   When exporting from Org to LaTeX, use ~latexmk~ for compilation.

   #+BEGIN_SRC emacs-lisp
   (eval-after-load 'ox-latex
     '(setq org-latex-pdf-process
            '("latexmk -pdflatex='pdflatex -shell-escape -interaction nonstopmode' -pdf -f %f")))
   #+END_SRC

   For my thesis, I need to use our university's LaTeX class, this snippet
   makes that class available.

   #+BEGIN_SRC emacs-lisp
   (eval-after-load "ox-latex"
     '(progn
        (add-to-list 'org-latex-classes
                     '("ifimaster"
                       "\\documentclass{ifimaster}
   [DEFAULT-PACKAGES]
   [PACKAGES]
   [EXTRA]
   \\usepackage{babel,csquotes,ifimasterforside,url,varioref}"
                      ("\\chapter{%s}" . "\\chapter*{%s}")
                      ("\\section{%s}" . "\\section*{%s}")
                      ("\\subsection{%s}" . "\\subsection*{%s}")
                      ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                      ("\\paragraph{%s}" . "\\paragraph*{%s}")
                      ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
       (custom-set-variables '(org-export-allow-bind-keywords t))))
   #+END_SRC

** Markdown

   This makes =.md=-files open in =markdown-mode=.

   #+BEGIN_SRC emacs-lisp
   (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
   #+END_SRC

   I sometimes use a specialized markdown format, where inline math-blocks
   can be achieved by surrounding a LaTeX formula with =$math$= and
   =$/math$=. Writing these out became tedious, so I wrote a small function.

   #+BEGIN_SRC emacs-lisp
   (defun insert-markdown-inline-math-block ()
     "Inserts an empty math-block if no region is active, otherwise wrap a
   math-block around the region."
     (interactive)
     (let* ((beg (region-beginning))
            (end (region-end))
            (body (if (region-active-p) (buffer-substring beg end) "")))
       (when (region-active-p)
         (delete-region beg end))
       (insert (concat "$math$ " body " $/math$"))
       (search-backward " $/math$")))
   #+END_SRC

   Most of my writing in this markup is in Norwegian, so the dictionary is
   set accordingly. The markup is also sensitive to line breaks, so
   =auto-fill-mode= is disabled. Of course we want to bind our lovely
   function to a key!

   #+BEGIN_SRC emacs-lisp
   (add-hook 'markdown-mode-hook
             (lambda ()
               (auto-fill-mode 0)
               (visual-line-mode 1)
               (ispell-change-dictionary "english")
               (local-set-key (kbd "C-c b") 'insert-markdown-inline-math-block)) t)
   #+END_SRC

** Python


   [[http://tkf.github.io/emacs-jedi/released/][Jedi]] offers very nice auto completion for =python-mode=. Mind that it is
   dependent on some python programs as well, so make sure you follow the
   instructions from the site.

   #+BEGIN_SRC emacs-lisp


   (use-package company-jedi
                :ensure t
                :config
                (setq jedi:environment-virtualenv (list (expand-file-name "~/.emacs.d/.python-environments")))
                (add-hook 'python-mode-hook 'jedi:setup)
                (setq jedi:complete-on-dot t)
                (setq jedi:use-shortcuts t)
                (add-hook 'python-mode-hook 'jedi:setup)
                (defun config/python-load-hook ()
                  (add-to-list 'company-backends 'company-jedi))
                (add-hook 'python-mode-hook 'config/python-load-hook))
   #+END_SRC

** Haskell

   =haskell-doc-mode= is similar to =eldoc=, it displays documentation in
   the echo area. Haskell has several indentation modes - I prefer using
   =haskell-indent=.

   #+BEGIN_SRC emacs-lisp
   (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
   (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
   #+END_SRC

* Key bindings

  Inspired by [[http://stackoverflow.com/questions/683425/globally-override-key-binding-in-emacs][this StackOverflow post]] I keep a =custom-bindings-map= that
  holds all my custom bindings. This map can be activated by toggling a
  simple =minor-mode= that does nothing more than activating the map. This
  inhibits other =major-modes= to override these bindings. I keep this at
  the end of the init-file to make sure that all functions are actually
  defined.

  #+BEGIN_SRC emacs-lisp
  (defvar custom-bindings-map (make-keymap)
   " keymap for custom bindings.")
  #+END_SRC

** Bindings for [[https://github.com/magnars/expand-region.el][expand-region]]

  #+BEGIN_SRC emacs-lisp
  (define-key custom-bindings-map (kbd "C->")  'er/expand-region)
  (define-key custom-bindings-map (kbd "C-<")  'er/contract-region)
  #+END_SRC

** Bindings for [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]

  #+BEGIN_SRC emacs-lisp
  (define-key custom-bindings-map (kbd "C-c e")  'mc/edit-lines)
  (define-key custom-bindings-map (kbd "C-c a")  'mc/mark-all-like-this)
  (define-key custom-bindings-map (kbd "C-c n")  'mc/mark-next-like-this)
  #+END_SRC

** Bindings for [[http://magit.github.io][Magit]]

  #+BEGIN_SRC emacs-lisp
  (define-key custom-bindings-map (kbd "C-c m") 'magit-status)
  #+END_SRC

** Bindings for [[http://company-mode.github.io/][company-mode]]

  #+BEGIN_SRC emacs-lisp
  (define-key company-active-map (kbd "C-d") 'company-show-doc-buffer)
  (define-key company-active-map (kbd "C-n") 'company-select-next)
  (define-key company-active-map (kbd "C-p") 'company-select-previous)
  (define-key company-active-map (kbd "<tab>") 'company-complete)

  (define-key company-mode-map (kbd "C-:") 'helm-company)
  (define-key company-active-map (kbd "C-:") 'helm-company)
  #+END_SRC

** Bindings for [[http://emacs-helm.github.io/helm/][Helm]]

  #+BEGIN_SRC emacs-lisp
  (define-key custom-bindings-map (kbd "C-c h")   'helm-command-prefix)
  (define-key custom-bindings-map (kbd "M-x")     'helm-M-x)
  (define-key custom-bindings-map (kbd "M-y")     'helm-show-kill-ring)
  (define-key custom-bindings-map (kbd "C-x b")   'helm-mini)
  (define-key custom-bindings-map (kbd "C-x C-f") 'helm-find-files)
  (define-key custom-bindings-map (kbd "<C-c h o>") 'helm-occur)
  (define-key custom-bindings-map (kbd "<C-c h g>") 'helm-google-suggest)
  (define-key custom-bindings-map (kbd "M-i")     'helm-swoop)
  (define-key custom-bindings-map (kbd "M-I")     'helm-multi-swoop-all)

  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
  (define-key helm-map (kbd "C-i")   'helm-execute-persistent-action)
  (define-key helm-map (kbd "C-z")   'helm-select-action)
  #+END_SRC

** Bindings for neotree
   Utilizing neotree is a blessing :)
   #+BEGIN_SRC emacs-lisp
     (global-set-key [f9] 'neotree-toggle)
   #+END_SRC

** Bindings for built-ins

  #+BEGIN_SRC emacs-lisp
  (define-key custom-bindings-map (kbd "M-u")         'upcase-dwim)
  (define-key custom-bindings-map (kbd "M-c")         'capitalize-dwim)
  (define-key custom-bindings-map (kbd "M-l")         'downcase-dwim)
  (define-key custom-bindings-map (kbd "M-]")         'other-frame)
  (define-key custom-bindings-map (kbd "C-j")         'newline-and-indent)
  (define-key custom-bindings-map (kbd "C-c s")       'ispell-word)
  (define-key custom-bindings-map (kbd "C-c c")       'org-capture)
  (define-key custom-bindings-map (kbd "C-x m")       'mu4e)
  (define-key custom-bindings-map (kbd "C-c <up>")    'windmove-up)
  (define-key custom-bindings-map (kbd "C-c <down>")  'windmove-down)
  (define-key custom-bindings-map (kbd "C-c <left>")  'windmove-left)
  (define-key custom-bindings-map (kbd "C-c <right>") 'windmove-right)
  (global-set-key [f10] 'toggle-menu-bar-mode-from-frame)
  (define-key custom-bindings-map (kbd "C-c t")
    (lambda () (interactive) (org-agenda nil "n")))
  (global-set-key [f10] 'toggle-menu-bar-mode-from-frame)
  #+END_SRC

** Bindings for extra plugins

   #+BEGIN_SRC emacs-lisp
   (define-key custom-bindings-map (kbd "<M-S-down>")  'move-text-down)
   (define-key custom-bindings-map (kbd "<M-S-up>")  'move-text-up)
   (define-key custom-bindings-map (kbd "C-D") 'duplicate-thing)
   (define-key custom-bindings-map (kbd "C-t t") 'yas-expand)
   (define-key custom-bindings-map (kbd "M-.") (function rtags-find-symbol-at-point))
   (define-key custom-bindings-map (kbd "M-,") (function rtags-find-references-at-point))
   #+END_SRC

** Bindings for functions defined [[sec:defuns][above]].
   
   #+BEGIN_SRC emacs-lisp
   ;; (define-key global-map          (kbd "M-p")     'jump-to-previous-like-this)
   ;; (define-key global-map          (kbd "M-n")     'jump-to-next-like-this)
   (define-key global-map          (kbd "C-c b")   'switch-to-previous-buffer)
   ;; (define-key custom-bindings-map (kbd "M-,")     'jump-to-previous-like-this)
   ;; (define-key custom-bindings-map (kbd "M-.")     'jump-to-next-like-this)
   (define-key custom-bindings-map (kbd "C-c .")   (cycle-themes))
   (define-key custom-bindings-map (kbd "C-x k")   'kill-this-buffer-unless-scratch)
   (define-key custom-bindings-map (kbd "C-c C-0") 'global-scale-default)
   ;; (define-key custom-bindings-map (kbd "C-c C-=") 'global-scale-up)
   (define-key custom-bindings-map (kbd "C-c C-+") 'global-scale-up)
   (define-key custom-bindings-map (kbd "C-c C--") 'global-scale-down)
   (define-key custom-bindings-map (kbd "C-x t")   'toggle-shell)
   (define-key custom-bindings-map (kbd "C-c j")   'cycle-spacing-delete-newlines)
   (define-key custom-bindings-map (kbd "C-c d")   'duplicate-thing)
   (define-key custom-bindings-map (kbd "<C-tab>") 'tidy)
   (define-key custom-bindings-map (kbd "C-c C-q")
     '(lambda ()
        (interactive)
        (focus-mode 1)
        (focus-read-only-mode 1)))
   (with-eval-after-load 'org
     (define-key org-mode-map (kbd "C-'") 'org-sync-pdf))
  #+END_SRC

   Lastly we need to activate the map by creating and activating the
  =minor-mode=.

  #+BEGIN_SRC emacs-lisp
  (define-minor-mode custom-bindings-mode
    "A mode that activates custom-bindings."
    t nil custom-bindings-map)
  #+END_SRC
  
* License
